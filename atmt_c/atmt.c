#include "atmt.h"

#define STARTVINI_OUT       3
#define GRAD_OUT            4
#define VNDRUDEOPTIMIZE_OUT 6

/* ************************************************************************** */
/* \/******************************************************* Изменяемая часть */
/* ======================================================================6.0= */
float fn_targetF(struct AFst *po_AFst)      /* структура со всеми параметрами */
/* -------------------------------------------------------------------------- */
{
  unsigned int ui_i;
  float        rez;

  /* \/ ---------------------------------------------------------- тело функции */
  for (ui_i=0; ui_i<(po_AFst->ui_argNumb); ui_i+=1)
    {
      rez += po_AFst->pa_TFarg[ui_i]*po_AFst->pa_TFarg[ui_i];
    }
  /* /\ ---------------------------------------------------------- тело функции */
  return rez;
}
/*** ===========================================================================
int fn_targetFIni
(
  struct AFst   *po_AFst,                           // указатель на аргументы ЦФ
  unsigned int  ui_fargN,                        // количество аргументов функции
  float         *Farg_a                             // массив аргументов функции
)
*/
/* ======================================================================6.1= */
int fn_targetFIni
(
  struct AFst  *po_AFst,                    /* структура со всеми параметрами */
  unsigned int  ui_fargN,
  float        *Farg_a
)
/* -------------------------------------------------------------------------- */
{
  po_AFst->ui_argNumb = ui_fargN;
  po_AFst->pa_TFarg   = Farg_a;

  return 1;
}
/*** ===========================================================================
int fn_targetFIni
(
  struct AFst   *po_AFst,                           // указатель на аргументы ЦФ
  unsigned int  ui_fargN,                        // количество аргументов функции
  float         *Garg_a                             // массив аргументов функции
)
*/
/* ======================================================================6.1= */
int fn_gradFIni
(
  struct AFst  *po_AFst,                    /* структура со всеми параметрами */
  unsigned int  ui_fargN,
  float        *Garg_a
)
/* -------------------------------------------------------------------------- */
{
  po_AFst->ui_argNumb = ui_fargN;
  po_AFst->pa_GRarg   = Garg_a;

  return 1;
}
/* /\******************************************************* Изменяемая часть */
/* ************************************************************************** */

/* ========================================================================1= */
unsigned short int fn_allIni                /* структура со всеми параметрами */
(
  struct AFst  *po_AFst,
  unsigned int  ui_fargN,
  float        *Farg_a,
  float        *Garg_a
)
/* -------------------------------------------------------------------------- */
{
  po_AFst->ui_argNumb  = ui_fargN;
  po_AFst->pa_TFarg    = Farg_a;
  po_AFst->pa_GRarg    = Garg_a;

  po_AFst->pfn_targetF = &fn_targetF;

  return 1;
}
/* ========================================================================2= */
int fn_startVini(struct AFst *po_AFst)      /* структура со всеми параметрами */
/* -------------------------------------------------------------------------- */
{
  unsigned int ui_i;
printf("%i \n", ui_i);
  for(ui_i = 0; ui_i<((po_AFst->ui_argNumb)); ui_i+=2)
    {
      /* шагаем по координтам */
      po_AFst->pa_TFarg[ui_i]   = -1.;
      po_AFst->pa_TFarg[ui_i+1] =  1.;
    }

  return STARTVINI_OUT;
}
/*** ===========================================================================
int fn_grad
(
  float          (*pfn_targetF)(struct AFst *po_AFst), // указатель на целевую функцию (ЦФ)
  struct AFst *po_AFst,                            // указатель на предварительно проинициализированные аргументы ЦФ
  struct GradV  *po_GradV,                             // указатель на аргументы градиента
  const int      Farg_N,                               // количество аргументов функции и градиента
  float          delta                                 // степ градиента
)
*/

/* ========================================================================3= */
int fn_grad(struct AFst *po_AFst)           /* структура со всеми параметрами */
/* -------------------------------------------------------------------------- */
{
  unsigned int ui_i;

  for (ui_i=0; ui_i<(po_AFst->ui_argNumb); ui_i+=1)
    {
      po_AFst->pa_TFarg[ui_i]  = po_AFst->pfn_targetF (po_AFst);
      po_AFst->pa_TFarg[ui_i] += po_AFst->delta;
      po_AFst->pa_TFarg[ui_i] -= po_AFst->pfn_targetF (po_AFst);
      po_AFst->pa_TFarg[ui_i] -= po_AFst->delta;
      po_AFst->pa_TFarg[ui_i] /= po_AFst->delta;
    }

  return GRAD_OUT;
}
/* ========================================================================5= */
/*
   следует обратить внимание, что одномерная оптимизация в данном слчучае
   одномерна относительно 2-х точек в которых вычислялся градиент, а потому
   мы работаем со всеми координатами вектора одновреммено как с одной
   координатой (масштабируя на общий коэффициент).
*/
int fn_VnDrudeOptimize(struct AFst *po_AFst)/* структура со всеми параметрами */
//------------------------------------------------------------------------------
{
  unsigned int ui_i;

  float f2;
  float f1;

  do
    {
      for(ui_i = 0; ui_i<(po_AFst->ui_argNumb); ui_i++)
        {
          /* шагаем по координтам */
          po_AFst->pa_xm[ui_i] =
            (po_AFst->pa_x2[ui_i] - po_AFst->pa_x1[ui_i])/2.;
        }

      fn_targetFIni(po_AFst, CONST, po_AFst->pa_x1);
      f1 = (po_AFst->pfn_targetF (po_AFst));
      fn_targetFIni(po_AFst, CONST, po_AFst->pa_x2);
      f2 = (po_AFst->pfn_targetF (po_AFst));

      if(f1 > f2)
        {
          po_AFst->pa_x2 = po_AFst->pa_xm;
        }
      else
        {
          po_AFst->pa_x1 = po_AFst->pa_xm;
        }
    }
  while((f2 - f1) >= STOPTHRESHOLD);

  return VNDRUDEOPTIMIZE_OUT;
}
/* ========================================================================8= */
int fn_closeAll(struct AFst *po_AFst)       /* структура со всеми параметрами */
/* -------------------------------------------------------------------------- */
{

  return 0;
}
/* ATMT-ATMT-ATMT-ATMT-ATMT-ATMT-ATMT-ATMT-ATMT-ATMT-ATMT-ATMT-ATMT-ATMT-ATMT */
/**
--------------------------------------------------------------------------------
             Автомат состояний обобщенного адаптивного фильтра.

 Общее описание состояний.

 1) инициализация переменных, порождение объектов
 2) задание произвольного начального вектора (точки)
 3) вычисление градиента(антиградиента)
 4) шагаем в сторону антиградиента с двукратным приростом вектора
 5) одномерная оптимизация (половинное деление)
 6) вычисление целевой функции
 7) проверка на критерий останова
 8) уничтожение объектов, закрытие дескрипторов, выход

 Алгоритм смены состояний(диаграмма переходов)
              ____________________
             |                    |
 1 --> 2 --> 3 --> 4(6(7)) --> 5(6(7)) ---> out
                     |__|


 3-и основные условия останова применяемых в методах оптимизации:
 1. n_iter >= MAX
 2. |targetF_targ(x*n) - targetF_targ(x*(n-1))| < threshold
 3. |x*n - x*(n-1)| < threshold

 Для градиентного метода вместо целевой функции как критерия останова можно
 использовать и минимум градиента. Поскольку в данном примере градиент
 вычисляется много реже целевой функции как критерий останова выбрана была
 последняя.
--------------------------------------------------------------------------------
*/
/* ========================================================================== */
unsigned short int fn_atmt(struct AFst *po_AFst)
/* структура со всеми параметрами */
/* -------------------------------------------------------------------------- */
{
  switch (po_AFst->usi_rSt)
    {
    case 0:                                                    /* состояние 0 */
      return 0;
      break;

    case 1:           
      po_AFst->usi_rSt = fn_startVini(po_AFst);                /* состояние 1 */
      break;

    case 3:                                                  /* состояние 1 */
      po_AFst->usi_rSt = fn_grad(po_AFst);
      break;

//    case 4:                                                  /* состояние 1 */
//      po_AFst->usi_rSt = fn_VnDrudeOptimize(po_AFst);
//      break;

    default:      /* состояние 32768 - закрытие всего и переход в состояние 0 */
      fn_closeAll(po_AFst);
      po_AFst->usi_rSt = 0;
    }

  return po_AFst->usi_rSt;
}
/* ========================================================================== */
int fn_atmtRun
(
  struct AFst  *po_AFst,
  unsigned int  usi_start
)        /* структура со всеми параметрами */
/* 1-e всегда вызов ini-функций или порождение объектов */
/* -------------------------------------------------------------------------- */
{
  po_AFst->usi_rSt = usi_start;

  do
    {
      po_AFst->usi_rSt = fn_atmt(po_AFst);
    }
  while (po_AFst->usi_rSt != 0);

  return (EXIT_SUCCESS);
}
/* ATMT-ATMT-ATMT-ATMT-ATMT-ATMT-ATMT-ATMT-ATMT-ATMT-ATMT-ATMT-ATMT-ATMT-ATMT */

